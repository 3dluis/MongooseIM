#!/usr/bin/env escript

-define(NO_ODBC_WARN, "WARNING! There is no odbc module in your Erlang/OTP installation! "
                      "It will not be included in the release!").

-record(opts, {apps         = [],
               log_dir      = "log",
               prefix       = "/usr/local",
               reltool_vars = "rel/configure.vars.config",
               user         = "mongooseim",
               system       = "no"}).

main([]) ->
    usage();
main(Args) ->
    case catch process_args(Args, #opts{}) of
        {ok, Opts} ->
            ok = write(shell, "configure.out", Opts),
            ok = write(reltool, Opts#opts.reltool_vars, Opts);
        error ->
            ok
    end.

app_opts() ->
    %% Opt         Apps                 Desc
    [{"none",      [],                  "include no 3rd party drivers"},
     {"all",       [],                  "include all drivers"},
     {"cassandra", ["seestar"],         include_driver("cassandra")},
     {"mysql",     ["mysql"],           include_driver("mysql")},
     {"odbc",      ["odbc"],            "include standard ODBC driver shipped with Erlang/OTP"},
     {"pgsql",     ["pgsql"],           include_driver("pgsql")},
     {"redis",     ["redo"],            include_driver("redis")},
     {"riak",      ["riakc", "riak_pb", "protobuffs"],
                                        include_driver("riak")}].

opts() ->
    [{"log-dir", (#opts{})#opts.log_dir, "Log directory. If relative, will be relative to $PREFIX/mongooseim"},
     {"prefix",  (#opts{})#opts.prefix,  "Installation PREFIX directory"},
     {"user",    (#opts{})#opts.user,    "System user to run the server as"},
     {"system",  (#opts{})#opts.system,  "Install files into $PREFIX/{bin, etc, ...} instead of "
                                         "a completely self contained release"}].

include_driver(DB) ->
    ["include ", DB, " driver"].

all_apps() ->
    lists:flatmap(fun ({_, Apps, _}) -> Apps end, app_opts()).

process_args(["with-" ++ App | Args], #opts{apps = Apps} = Opts) ->
    process_args(Args, Opts#opts{apps = process_app(App, Apps)});

process_args(["log-dir=" ++ LogDir | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{log_dir = LogDir});
process_args(["log-dir", LogDir | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{log_dir = LogDir});

process_args(["prefix=" ++ Prefix | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{prefix = Prefix});
process_args(["prefix", Prefix | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{prefix = Prefix});

process_args(["system=" ++ System | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{system = System});
process_args(["system" | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{system = "yes"});

process_args(["user=" ++ User | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{user = User});
process_args(["user", User | Args], #opts{} = Opts) ->
    process_args(Args, Opts#opts{user = User});

process_args([Unknown | _Args], #opts{} = _Opts) ->
    print(standard_error, "~s: unknown option: ~s~n", [progname(), Unknown]),
    throw(error);

process_args([], Opts) -> {ok, Opts}.

process_app("none", _Apps) -> [];
process_app("all", _Apps)  -> all_apps();
process_app(App, Apps)     -> [App | Apps].

validate_apps(Apps) -> validate_apps(Apps, []).

validate_apps(["odbc" = App | Apps], Acc) ->
    case is_odbc_available() of
        false -> io:format(standard_error, "~s~n", [?NO_ODBC_WARN]),
                 validate_apps(Apps, Acc);
        true  -> validate_apps(Apps, [App | Acc])
    end;
validate_apps([App | Apps], Acc) -> validate_apps(Apps, [App | Acc]);
validate_apps([], Acc) -> lists:reverse(Acc).

is_odbc_available() ->
    {module, odbc} == code:ensure_loaded(odbc).

usage() ->
    print(standard_error,
          "~s: OPTIONS\n"
          "\n"
          "Specifies which 3rd party deps will be included in the release.\n"
          "Allows to configure LOG_DIR or installation PREFIX.\n"
          "Writes configure.out file as output. This file can be sourced with:\n"
          "\n"
          "    . configure.out\n"
          "\n"
          "3rd party apps:\n\n~s\n"
          "Options:\n\n~s\n",
          [progname(),
           [ io_lib:format("    with-~.15s~s\n", [Opt, Desc])
             || {Opt, _, Desc} <- app_opts() ],
           [ io_lib:format("    ~.10s~s. Default: ~s\n", [Opt, Desc, Default])
             || {Opt, Default, Desc} <- opts() ]]).

print(Handle, Fmt, Args) ->
    io:format(Handle, Fmt, Args).

progname() ->
    filename:basename(hd(init:get_plain_arguments())).

sh_var(Name, Value) -> ["export ", Name, "=\"", value(Value), "\"\n"].

value([]) -> [];
value([V]) -> [V];
value([H | T]) -> [H, " "] ++ value(T).

rt_var(Name, Value) -> io_lib:format("{~s, ~p}.\n", [Name, Value]).

write(shell, FileName, Opts) ->
    Data = [sh_var("MONGOOSEIM_CONFIGURED", ["yes"]),
            sh_var("APPS", validate_apps(Opts#opts.apps)),
            sh_var("PREFIX", [Opts#opts.prefix]),
            sh_var("RELTOOL_VARS", [Opts#opts.reltool_vars]),
            sh_var("RUNNER_USER", [Opts#opts.user]),
            sh_var("SYSTEM", [Opts#opts.system])],
    file:write_file(FileName, Data);

write(reltool, FileName, Opts) ->
    Data = [rt_var(mongooseim_log_dir, Opts#opts.log_dir),
            rt_var(mongooseim_runner_user, Opts#opts.user)],
    file:write_file(FileName, Data).
